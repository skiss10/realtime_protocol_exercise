Sesions should stored globally and mapped connection id: to connection - update reconnection logic so the new object is a copy of hte old connection object (maybe?)

update reconnection_attempt_message_handler to remove old connection from session store and update new connection with needed params from reconnection and old connection object

Do this (different than current implementation):  the client must supply connection parameters that allow the server to continue the sequence starting with the first undelivered number.

0.01) clean up print statements and comments in files

0.015) refactor code ... lots of ugliness in reconnection handlers, etc.

0.02) add a session object to each connection to keep track of the messages sent to clients

0.03) add either a new function on the server or as part of the connection method to delete storage and prevent reconencts if reconnect after ___ seconds. Thsi will run in parallel to the client thread

0.04) Update testingproxy.py and testingserver.py to handle server failures ( in prep of redis storage vs inmemorydatastore )


Remove "with connection.threading_lock" from check_heartbeat_ack in testingserver.py










0.5)  Implement these properties for the connection object: https://ably.com/docs/api/realtime-sdk/connection?lang=nodejs
Implement methods to run upon initialization of Connection object (Setting raddr, etc.)
Implement greeting response from server to client with connection_id, perhaps set this equal to the thread ID

- Create a prompt for user input when running client.py asking if the user wants to simulate a disconnection. If yes, then for how long (in seconds)
- Update client.py server_handler or message_handler to have logic that if discconect simulation is True, disconnect for that time (this will be just socket.disconnect, time.sleep. socket.reconnect) async somewhere here..
- Update client.py to format a reconnection type message and logic to send 
- Update server.py to handling incoming reconnection type requets (rejecting any older than 120 seconds)
-


6) Add a variable to constants.py to simulate various connection types (SSE vs. Socket. vs. gRPC)


7) Refactor client.py message_handler with a handler dictionary mapping:

def message_handler(msg):
    handlers = {
        "hello": handle_hello,
        "goodbye": handle_goodbye,
        "ping": handle_ping,
        # add more message types and their handlers here
    }
    handler = handlers.get(msg["type"], handle_unknown)
    return handler(msg)

def handle_hello(msg):
    # handle the "hello" message type
    pass

def handle_goodbye(msg):
    # handle the "goodbye" message type
    pass

def handle_ping(msg):
    # handle the "ping" message type
    pass

def handle_unknown(msg):
    # handle any unknown message types
    pass